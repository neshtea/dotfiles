* Emacs Configuration
  This is my first attempt for a literate Emacs configuration.  I will
  follow the pointers from [[https://loy-aqua.github.io/emacs/2020/06/28/literate-emacs-config.html][this guide]], using [[https://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]] to compile the
  literate configuration to emacs lisp.
* Package Management
  #+begin_src emacs-lisp
    ;; We install packages via nix home-manager, but we still configure
    ;; them via use-package
    (require 'use-package)
  #+end_src
  I managed my Emacs as well as (almost) all packages I use with
  [[https://github.com/nix-community/home-manager][=home-manager=]]. Therefore, I don't really "manage packages" in this
  configuration but only configure and initialize them.  For said
  configuration, I use [[https://www.emacswiki.org/emacs/UsePackage][=use-upackage=]].
* Generic Editor configuration
  This section sets some basic configuration that concerns Emacs'
  behaviour as a whole.
** Startup Behaviour
   On startup, we don't want to see the default Emacs splash screen.
   #+begin_src emacs-lisp
     (setq inhibit-splash-screen t)
   #+end_src

   Custom usually clutters the actual init file.  We tell it to use
   it's own file here and load the contents of the custom file.  Since
   we're usually not intentionally setting any custom options, we also
   ignore any errors in custom.
   #+begin_src emacs-lisp
     (setq custom-file (expand-file-name "~/.config/emacs/custom.el"))
     (load custom-file 'no-error)
   #+end_src

   Especially on MacOS, I always struggle with things on my path and
   how and if Emacs will be able to find them.  [[https://github.com/purcell/exec-path-from-shell][=exec-path-from-shell=]]
   tries to help.  Honestly, it doesn't always do the right thing for
   me, but it's better than nothing I guess.
   #+begin_src emacs-lisp
     ;; Especially on MacOS, the exec path is always wrong.  This package
     ;; tries to fix that.
     (use-package exec-path-from-shell
       :config
       ;; Point to the fish shell installed via home-manager/nix.
       (setenv "SHELL" (expand-file-name "~/.nix-profile/bin/fish"))
       (exec-path-from-shell-initialize)
       (exec-path-from-shell-copy-envs '("PATH")))
   #+end_src
** =general=
   To get off the ground, we start with =general=.
    [[https://github.com/noctuid/general.el][=general=]] provides very convenient and easy to understand macros
    to define keyboard shortcuts.  For me, it replaced [[https://github.com/cofi/evil-leader][=evil-leader=]]
    and I use it primarly to define keys for global and mode-specific
    functions.
    In particular, it does the following:
    - Bind my leader-key to =SPC= in normal-mode.
    - Bind my leader-key to =C-SPC= in other modes (so I can still use
      global bindings when in insert-mode).
    - A "definer" for leader-prefixed commands (=def-with-leader=).
    - A "definer" for local-prefixed commands
      (=def-with-local-leader=).  The local leader key is bound to
      =,=.

    By local, I mean mode specific bindings. For example, in a Clojure
    buffer (a case of local bindings), =cider-apropos= is bound to =,
    h a=, wheres accessing my org agenda is bound to =SPC a o a=
    (binding a global funciton).
    #+begin_src emacs-lisp
      ;; General is used to define keybindings (replaces evil-leader).
      (require 'general)
      
      ;;    We define two general definers here:
      ;; 1. def-with-leader: Define "global" keys, prefixed by "SPC"
      ;; 2. def-local-with-leader: Define "local" keys (keys for
      ;;    specific modes, i.e. org-mode, clojure, ...)
      (general-create-definer def-with-leader
	:keymaps 'override
	:states '(normal insert emacs visual motion)
	:prefix "SPC"
	:non-normal-prefix "C-SPC")
      
      (general-create-definer def-local-with-leader
	:keymaps 'override
	:states '(normal insert emacs visual motion)
	:prefix ","
	:non-normal-prefix "C-,")
    #+end_src
** Editor Behaviour
   There are some basics we want to get done right at the start.
   First, we want to always load the current version of the file a
   buffer is displaying.
   #+begin_src emacs-lisp
     ;; Always prefer the "newer" version of a file.
     (setq load-prefer-newer t)
   #+end_src

   Emacs usually asks yes-no questions and expects you to answer with
   =yes= or =no=.  We would rather answer with =y= or =n=.
   #+begin_src emacs-lisp
     ;; Answer yes-or-no questions with y or n
     ;; http://pragmaticemacs.com/emacs/make-all-prompts-y-or-n/
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

   Also, we want to always revisit a file where we left off:
   #+begin_src emacs-lisp
     ;; "When you visit a file, point goes to the last place where it was
     ;; when you previously visited the same file."
     ;; https://www.emacswiki.org/emacs/SavePlace
     (save-place-mode 1)
   #+end_src

   If possible, we want to help visually parsing matching parentheses,
   so we highlight them.
   #+begin_src emacs-lisp
     ;; Alwas show matching parens.
     (show-paren-mode 1)
   #+end_src

   Sometimes it is useful to quickly switch between the current
   buffer and the buffer last visited.
   #+begin_src emacs-lisp
     ;; https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/
     (defun er-switch-to-previous-buffer ()
       "Switch to previously open buffer.
	   Repeated invocations toggle between the two most recently open buffers."
       (interactive)
       (switch-to-buffer (other-buffer (current-buffer) 1)))
     
     (def-with-leader
       "TAB" #'er-switch-to-previous-buffer)
   #+end_src

   If I really need to concentrate, I like to put Emacs into
   full-screen mode.
   #+begin_src emacs-lisp
     (defun toggle-fullscreen ()
       "Toggle full screen"
       (interactive)
       (set-frame-parameter
	nil 'fullscreen
	(when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

     (def-with-leader
       "f s" #'toggle-fullscreen)
     
   #+end_src
*** Code Folding
    For code-folding, I use [[https://github.com/gregsexton/origami.el][=origami=]].
    #+begin_src emacs-lisp
      ;; Code folding, also used by evil.
      (use-package origami
	:init
	(global-origami-mode))
    #+end_src
*** golden-ratio
    Sometimes it is useful to split buffers in other ratios than
    50/50.  The [[https://github.com/cyrus-and/zoom][zoom]] package allows us to use arbitrary ratios,
    especially a "golden-ratio" mode.
    #+begin_src emacs-lisp
      ;; Used for golden-ration mode.
      (use-package zoom
	:config
	;; Resize the selected window using the golden ratio:
	;; https://github.com/cyrus-and/zoom#example-configurations
	(setq zoom-size '(0.618 . 0.618)))
      
      (def-with-leader
	"z z" #'zoom-mode)
    #+end_src
*** Font-size Adjustments
    It is notoriously incenvenient to adjust font size in Emacs.  I
    decided to use [[https://github.com/abo-abo/hydra][=hydra=]] to define a font-size hydra (a persistent
    minibuffer that allows for multiple commands before it is closed).
    #+begin_src emacs-lisp
      ;; Define little states that stay in the minibuffer.
      (use-package hydra
	:config
	(defhydra hydra-zoom (global-map "C-#")
	  "zoom"
	  ("+" text-scale-increase "increase")
	  ("-" text-scale-decrease "decrease")
	  ("0" text-scale-adjust "reset")))
      
      (def-with-leader
	"f z" #'hydra-zoom/body)
    #+end_src
** Backups
   In general, we don't want emacs to write any backup files.
   #+begin_src emacs-lisp
     (setq make-backup-files nil)
   #+end_src 
** OS Specifics
   I only work on MacOS, therefore I can decide to always remap some
   modifier keys to a more sensible location on the keyboard.
   #+begin_src emacs-lisp
     (setq ns-alternate-modifier 'none
	   ns-command-modifier 'meta
	   ns-function-modifier 'super)
   #+end_src
** Visual
   We want as little visual clutter as possible.  Therefore, we
   disable the menubar, the scrollbar and to toolbar by default.
   While not exactly visual, we also disable the bell entirely.
   #+begin_src emacs-lisp
     (menu-bar-mode -1)
     (toggle-scroll-bar -1)
     (tool-bar-mode -1)
     ;; Turn off all alarms completely.
     ;; See https://www.emacswiki.org/emacs/AlarmBell.
     (setq ring-bell-function 'ignore)
   #+end_src

   We use Roboto-Mono font, which can be previewed [[https://fonts.google.com/specimen/Roboto+Mono][here on Google
   Fonts]]
   #+begin_src emacs-lisp
     (set-frame-font "Roboto Mono-14" t t)
   #+end_src

   I also use [[https://github.com/tarsius/hl-todo][=hl-todo=]] to highlight all sorts of TODOish keywords.
   #+begin_src emacs-lisp
     (use-package hl-todo
       :init
       (add-hook 'after-init-hook 'global-hl-todo-mode))
   #+end_src
*** Themes
    I can never really decide on a theme.  Right now I like two groups
    of themes the most:
    
    - The [[https://github.com/hlissner/emacs-doom-themes][emacs-doom-themes]] collection, especially very basic
      =doom-one=.
    - The pair of [[https://github.com/protesilaos/modus-themes/][modus-themes]].  Very readable because of very high
      contrast, sadly aesthetically less pleasing than the Doom
      themes.

    Also included is the very nice [[https://github.com/hlissner/emacs-solaire-mode][emacs-solair-mode]].  It uses a
    slightly different theme for file-buffers versus other-buffers
    (i.e. =dired= buffers, etc.), which helps with quickly finding
    what your looking for on the screen.  Unfortunately, right now it
    only works with the =emacs-doom-themes= package.

    #+begin_src emacs-lisp
      ;; Copied from Johannes init.el
      ;; https://github.com/kenranunderscore/dotfiles/blob/main/modules/programs/emacs/emacs.d/init.el#L80
      (defun my--switch-theme (name)
	"Switch themes interactively.  Similar to `load-theme' but also
      disables all other enabled themes."
	(interactive
	 (list (intern
		(completing-read
		 "Theme: "
		 (mapcar #'symbol-name
			 (-difference (custom-available-themes)
				      custom-enabled-themes))))))
	(progn
	  (mapcar #'disable-theme
		  custom-enabled-themes)
	  (load-theme name t)))
      
      (def-with-leader
	"s t" '(my--switch-theme :which-key "change theme"))
      
      
      ;; Some themes to choose from besides the basic ones.
      (use-package doom-themes
	:defer t
	:init
	;; Make doom-one the default.
	(my--switch-theme 'doom-one))
      
      ;; Very nice thems in terms of readability and contrast, perhaps a
      ;; little dull.
      (use-package modus-themes
	:defer t)
      
      ;; Distinguish file-visiting buffers from other ones. Only works with
      ;; doom-themes (and maybe a few others).
      (use-package solaire-mode
	:init
	(solaire-global-mode +1))     
    #+end_src
*** Modeline
    The default modeline is a little boring.  I like the
    [[https://github.com/seagle0128/doom-modeline][doom-modeline]], which looks nice and has built-in support for lots
    of little things (I like the file-symbols, for example).
    
    #+begin_src emacs-lisp
      ;; Nicer modeline with symbols, etc.
      (use-package doom-modeline
	:init (doom-modeline-mode 1)
	:config
	(setq doom-modeline-height 25))
    #+end_src
** Auto-completion and Incremental Narrowing
   For auto-completion in buffers, I rely on the good-old
   [[https://company-mode.github.io/][=company-mode]].
   #+begin_src emacs-lisp
     ;; Complete anything -- auto completion framework.
     (use-package company
       :hook ((after-init . global-company-mode)))
   #+end_src

   For other completions (e.g. in Minibuffers, etc.), I've recently
   switched to [[https://github.com/raxod502/selectrum][=selectrum=]], a really nice incremental narrowing
   solution.  For me, it replaced =helm=.  I also include
   [[https://github.com/raxod502/prescient.el][=selectrum-prescient=]], which helps surfacing requently used
   completions.
   #+begin_src emacs-lisp
     ;; Selectrum is a better solution for incremental narrowing in Emacs, 
     ;; replacing Helm, Ivy, and Ido.
     ;; https://github.com/raxod502/selectrum
     (use-package selectrum :init (selectrum-mode +1))
     
     ;;; selectrum-prescient
     ;; selectrum-prescient helps with surfacing frequently used
     ;; completions.
     (use-package selectrum-prescient
       :after selectrum
       :init
       (selectrum-prescient-mode +1)
       (prescient-persist-mode +1))
   #+end_src
** Helpers and Groundwork
   In this section, we configure generic helpers that make general
   editing and usage more easy.
   It also contains what I call "groundwork", which means the very
   basics everything else will need or hook into, such as =general=,
   =evil=, etc.
*** =which-key=
    [[https://elpa.gnu.org/packages/which-key.html][=which-key=]] allows you to quickly see what next keys do what.  If
    you press for example =C-l=, it displays all possible next
    commands and what they do.
    #+begin_src emacs-lisp
      ;; Display possible keyboard shortcut completions.
      (use-package which-key
	:custom
	(which-key-idle-delay 0.3)  ; Show completions relatively fast.
	:init
	;; We always want to display completions.
	(add-hook 'after-init-hook #'which-key-mode))
    #+end_src
*** =magit=
    Magit is so awesome, you might want to use Emacs just to be able to
    use Magit!  We don't configure much, just that when entering
    =git-commit-mode=, we want to start in insert-mode to quickly start
    typing.

    #+begin_src emacs-lisp
      (use-package diff-hl
	:init (global-diff-hl-mode))
      
      ;; Magit (and Neogit for Neovim) are the very best tools for
      ;; interacting with git.
      (use-package magit
	:hook (git-commit-mode . evil-insert-state)
	:after diff-hl
	:config
	(setq-default git-magit-status-fullscreen t)
	(add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
	(add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
      
      (def-with-leader
	"g i" #'magit-init
	"g s" #'magit)
    #+end_src
*** =evil=
    I use [[https://www.emacswiki.org/emacs/Evil][=evil=]] for my editing (what else, you monster?).  There is
    not much to say about the evil-package itself -- it's just
    globally activated on startup and there you go.
    
    #+begin_src emacs-lisp
	    ;;;;  evil
      ;; Make editing files a little saner (that is, make it behave like
      ;; vim).
      (use-package evil
	:init
	(setq evil-want-integration t) ;; This is optional since it's already set to t by default.
	(setq evil-want-keybinding nil)
	:config
	(evil-mode 1)  ; TODO shouldn't this be in :init?
	(setq evil-undo-system 'emacs))
    #+end_src
**** =evil-collection= and =evil-org=
     [[https://github.com/emacs-evil/evil-collection][=evil-collection=]] contains a large repository of behaviours that
     make lots modes behave the way you would expect in evil-mode.
     [[https://github.com/Somelauw/evil-org-mode][=evil-org-mode=]] does the same for org-mode buffers.
     #+begin_src emacs-lisp
       (use-package evil-collection
	 :after (evil)
	 :config
	 (evil-collection-init))
       
       ;; Same as evil-collection, but specific to org-mode.
       ;; https://github.com/Somelauw/evil-org-mode
       (use-package evil-org
	 :after (evil org)
	 :hook (org-mode . evil-org-mode)
	 :config
	 (require 'evil-org-agenda)
	 (evil-org-agenda-set-keys))
     #+end_src
**** =evil-nerd-commenter=
     [[https://github.com/redguardtoo/evil-nerd-commenter][=evil-nerd-commenter=]] is a little tool inspired by VIM's
     [[https://github.com/preservim/nerdcommenter][=nerd-commenter=]].  Comment or uncomment lines or regions with
     =SPC ;=.
     
     #+begin_src emacs-lisp
     ;; Make commenting a little easier.
     (use-package evil-nerd-commenter)
     (def-with-leader
     ";" #'evilnc-comment-or-uncomment-lines)
     #+end_src emacs-lisp
*** =paredit=
    I really like paredit (although people are recommending other
    stuff all the time).
    I just attach it to every LISP-like language buffer and am stil
    happy with it.
    #+begin_src emacs-lisp
      ;; Paredit allows to easily work with parens. Especially useful in
      ;; LISP-like languages.
      (use-package paredit
	:config
	(autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
	;; TODO :hook
	(add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
	(add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
	(add-hook 'ielm-mode-hook             #'enable-paredit-mode)
	(add-hook 'lisp-mode-hook             #'enable-paredit-mode)
	(add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
	(add-hook 'scheme-mode-hook           #'enable-paredit-mode)
	(add-hook 'clojure-mode-hook          #'enable-paredit-mode))
    #+end_src
*** Quickly restart Emacs
    Sometimes it is useful to quickly restart remacs from within Emacs
    itself.
    #+begin_src emacs-lisp
      ;; Easily restart emacs. Sadly useful from time to time.
      (use-package restart-emacs)
      (def-with-leader
	"q r" #'restart-emacs)
    #+end_src
*** Projectile
    This is just a nice way to jump between projects (and finding
    project roots for =consult=).
    #+begin_src emacs-lisp
      ;; Easily find projects and files within projects.
      (use-package projectile
	:init
	(projectile-mode +1))
      
      (def-with-leader
	"p p" #'projectile-switch-project
	"p f" #'project-find-file)
    #+end_src
*** Getting help with =consult=
    [[https://github.com/minad/consult][=consult=]] is a package that hooks into Emacs'
    completing-read-function.  It provides many different and helpful
    completions, such as consultation of
    
    - your history
    - buffers
    - bookmarks
    - outlines
    - project contents (via gitgrep)

    and much more.
    I pair it with [[https://github.com/minad/marginalia][=marginalia=]] to add more useful information to
    =consult= minibuffer completions.
    #+begin_src emacs-lisp
      ;; consult provides a huge array of cap based searches.
      (use-package consult
        :after projectile
	:init
	(setq register-preview-delay 0
	      register-preview-function #'consult-register-format)
	(advice-add #'register-preview :override #'consult-register-window)
	(advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
      
	:hook (completion-list-mode . consult-preview-at-point-mode)
	:config
	(autoload 'projectile-project-root "projectile")
	(setq consult-project-root-function #'projectile-project-root))
      
      (def-with-leader
	"c m" #'consult-mode-command
	"c h" #'consult-history
	"c b" #'consult-bookmark
	"c l" #'consult-line
	"c o" #'consult-outline
	"b b" #'consult-buffer
	"/" #'consult-git-grep)
      
      ;; marginalia annotates completion candidates in the completion at
      ;; point buffer. Plays nicely with consult, etc.
      (use-package marginalia :init (marginalia-mode))
     #+end_src
*** =helpful=
    The builtin Emacs =*help*= buffers leave much to be desired,
    especially contextual information. [[https://github.com/Wilfred/helpful][=helpful=]] helps with that.
    #+begin_src emacs-lisp
      (use-package helpful)
      
      (def-with-leader
	"h f" #'helpful-callable
	"h v" #'helpful-variable
	"h k" #'helpful-key
	"h p" #'helpful-at-point)
    #+end_src
** Top Level Keybindings
   Some keybindings that have nothing to do with any other mode are
   defined here.
   #+begin_src emacs-lisp
     ;; Perhaps this is a good point to make a shortcut to my home-manager
     ;; config file (and some more files, too).
     (defun home-manager-visit-config ()
       (interactive)
       (find-file (expand-file-name "~/.config/nixpkgs/home.nix")) )
     
     (defun emacs-visit-init-el ()
       (interactive)
       (find-file (expand-file-name "~/.emacs.d/init.el")))
     
     (def-with-leader
       "t l" #'global-display-line-numbers-mode
       "t f" #'display-fill-column-indicator-mode
       "s h" #'eshell
       "f f n" #'home-manager-visit-config
       "f f e" #'emacs-visit-init-el
       "SPC" '(execute-extended-command :which-key "M-x"))
   #+end_src
* Org-Mode
  Org-mode deserves it's own section here.  There is actually not a
  whole lot to say, just a lot to configure.  My Emacs is setup to
  allow for a GTD-style org-usage (you can find a primere [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][here]]).
  I like to log state-changes to todos into the drawer which can be
  done with =org-log-into-drawer=.
  #+begin_src emacs-lisp
    (use-package org
      :config
      (add-hook 'org-mode-hook #'auto-fill-mode)
      (setq org-adapt-indentation t
	    org-hide-leading-stars t
	    org-return-follows-link t
	    ;; Use org-mode for the initial *scratch* buffer.
	    initial-major-mode 'org-mode
	    ;; Start any org-file in "overview"-mode.
	    org-startup-folded t
	    org-agenda-files '("~/Box/Brain/Tasks/inbox.org"
			       "~/Box/Brain/Tasks/gtd.org"
			       "~/Box/Brain/Tasks/tickler.org")
	    org-capture-templates '(("t" "Todo [inbox/work]" entry
				     (file "~/Box/Brain/Tasks/inbox.org")
				     "* TODO %i%? \n  %U")
				    ("c" "Capture [inbox]" entry
				     (file "~/Box/Brain/Tasks/inbox.org")
				     "* TODO %i%?\n  %a")
				    ("r" "Respond to email" entry
				     (file "~/Box/Brain/Tasks/inbox.org")
				     "* TODO Respond to %:from on %:subject  :email: \nSCHEDULED: %t\n%U\n%a\n"
				     :immediate-finish t))
	    org-refile-targets '(("~/Box/Brain/Tasks/gtd.org" :maxlevel . 3)
				 ("~/Box/Brain/Tasks/lists.org" :maxlevel . 2)
				 ("~/Box/Brain/Tasks/someday.org" :level . 1))
	    ;; When the state of a section headline changes, log the
	    ;; transition into the headlines drawer.
	    org-log-into-drawer 'LOGBOOK
	    org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "INPROGRESS(p!)" "|" "DONE(d!)" "CANCELLED(c!)"))))
    
    (use-package org-contrib
      :config
      (require 'ol-notmuch))
    
    (def-with-leader
      "a o a" #'org-agenda-list
      "a o t" #'org-todo-list
      "a o c" #'consult-org-agenda
      "C c"   #'org-capture)
    
    (def-local-with-leader
      :keymaps '(org-mode-map org-agenda-mode-map)
      "d d" #'org-deadline
      "d s" #'org-schedule
      "s A" #'org-archive-subtree
      "s l" #'org-demote-subtree
      "s h" #'org-promote-subtree
      "s k" #'org-move-subtree-up
      "s j" #'org-move-subtree-down
      "s r" #'org-refile
      "s s" #'org-sparse-tree
      "s S" #'org-sort-entries
    
      "i d" #'org-insert-drawer
      "i l" #'org-insert-link
      "i n" #'org-add-note
      "i t" #'org-set-tags-command
    
      "T c" #'org-toggle-checkbox
      "T i" #'org-toggle-inline-images
      "T t" #'org-todo
    
      "x o" #'org-open-at-point)
  #+end_src
** org-roam
   [[https://www.orgroam.com/][=org-roam=]] is what I use for my Zettelkasten.  It uses =v2= of
   =org-roam= which should be the default for most newcomers by now.
   I also added [[https://github.com/jrblevin/deft][=deft=]] for a somewhat nicer search interface to my
   notes.  To be honest, I usually just gitgrep through it be oh well.
   #+begin_src emacs-lisp
     ;; Roam inspired mode for my zettelkasten using org mode.
     (use-package org-roam
       :after org
       :init
       (setq org-roam-v2-ack t)
       :config
       (setq org-roam-directory "~/Box/Brain/Knowledge/"
	     org-roam-index-file "index.org")
       (add-hook 'after-init-hook 'org-roam-mode)
       (require 'org-roam-protocol)
       (org-roam-setup))
     
     ;; TODO Maybe use =notdeft=? But it's harder to install and configure...
     ;; TODO Perhaps consult-git-grep is enough?
     ;; Deft makes it easy to do full-text search on a certain directory
     ;; (and it's children).
     (use-package deft
       :after org
       :hook (deft-mode . evil-insert-state)
       :custom
       (deft-recursive t)
       (deft-use-filter-string-for-filename t)
       (deft-default-extension "org")
       (deft-directory org-roam-directory))
     
     (def-with-leader
       "r n f" #'org-roam-node-find
       "r n c" #'org-roam-capture
       "r n i" #'org-roam-insert
       "r n t" #'org-roam-buffer-toggle
       "r n g" #'org-id-get-create
       "r n a a" #'org-roam-alias-add
       "r n a r" #'org-roam-alias-remove)
     
   #+end_src
* Programming Languages
** Syntax highlighters
   Some packages are only included to provide syntax highlighting and
   indentation rules for some specific formats.  Some of them can do
   more -- but if they are included in this section, I don't use any
   more or very little functionality other than that (e.g. the
   =markdown-mode= package is included that can also export md as html
   etc.).

   These packages provide support for:
   - Dockerfiles
   - Yaml
   - Markdown
   - nix
   - LaTeX
   - Lua
   #+begin_src emacs-lisp
     ;; Highlights docker files and provides some basic commands (none of
     ;; which I use).
     (use-package dockerfile-mode
       :init (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))
     
     ;; Highighting and indentation for yaml.
     (use-package yaml-mode
       :init (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode)))
     
     ;; Syntax highlighting for markdown files. Requires multimarkdown to
     ;; be installed on the system.
     (use-package markdown-mode
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
	      ("\\.md\\'" . markdown-mode)
	      ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-command "multimarkdown"))
     
     (use-package tex-mik
       ;; :hook (org-mode . evil-org-mode)
       :hook ((LaTeX-mode . auto-fill-mode)
	      (LaTeX-mode . LaTeX-math-mode))
       :config
       ;; Automatically compile to PDF.
       (setq TeX-PDF-mode t))
     
     ;; Work with nix files (syntax highlighting and indentation). 
     (use-package nix-mode
       :mode "\\.nix\\'")
     
     ;; https://github.com/immerrr/lua-mode
     (use-package lua-mode)
   #+end_src
** Clojure
   Working with Clojure is very easy in Emacs.  I use [[https://cider.mx/][=cider=]] for
   interactive development with a REPL that I can talk to from emacs.
   Soem nice functionality comes from [[https://github.com/clojure-emacs/clj-refactor.el][=clj-refactor=]].

   I repeadetly tested [[https://clojure-lsp.io/][=clojure-lsp=]] but never found any use for it,
   so it isn't included here.
   #+begin_src emacs-lisp
     ;; Working Clojure needs almost no configuration, just some nice
     ;; packages (ciderm, clj-refactor, clojure-mode).
     (use-package clj-refactor)
     (use-package clojure-mode)
     (use-package cider)
     
     (def-local-with-leader
       :keymaps 'clojure-mode-map
       "= =" #'clojure-align
       "h a" #'cider-apropos
       "h c" #'cider-cheatsheet
       "h d" #'cider-clojuredocs
       "h j" #'cider-javadoc
       "h h" #'cider-doc
       "h n" #'cider-browse-ns
       "h s" #'cider-browser-spec
       "e ," #'cider-eval-sexp-at-point
       "e b" #'cider-eval-buffer
       "e e" #'cider-eval-last-sexp
       "e m" #'cider-macroexpand-1
       "e n a" #'cider-ns-reload-all
       "t a" #'cider-test-run-ns-tests
       "t t" #'cider-test-run-test)
     
     ;; https://github.com/clojure-emacs/clj-refactor.el
     (defun custom-clojure-mode-hook ()
       "Turn on clj-refactor in clojure-mode."
       (clj-refactor-mode 1)
       (yas-minor-mode 1))
     
     (add-hook 'clojure-mode-hook #'custom-clojure-mode-hook)
   #+end_src
** Elixir
   At the moment, I don't work with Elixir a lot anymore.  This means
   that this configuration section is more of a relic that, by the
   time I start using Elixir more, will get updated.
   Most of the interesting stuff comes from [[https://alchemist.readthedocs.io/en/latest/][Alchemist]].  We need to
   tell Alchemist where our executables are (since they are installed
   from nix and not found where they are expected to be.  Other than
   that, there's not much to do.
   #+begin_src emacs-lisp
	  ;;;; Elixir
     (use-package elixir-mode
       :hook (elixir-mode . (lambda () 
			      (add-hook 'before-save-hook 'elixir-format nil t))))
     
     (use-package alchemist
       :config
       ;; See https://alchemist.readthedocs.io/en/latest/configuration/
       (setq alchemist-mix-command (expand-file-name "~/.nix-profile/bin/mix")
	     alchemist-iex-program-name (expand-file-name "~/.nix-profile/bin/iex")
	     alchemist-execute-command (expand-file-name "~/.nix-profile/bin/elixir")
	     alchemist-compile-command (expand-file-name "~/.nix-profile/bin/elixirc")))
     
     (def-local-with-leader
       :keymaps 'elixir-mode-map
       "a x" #'alchemist-mix
       "a c" #'alchemist-mix-compile
       "a r" #'alchemist-mix-run
     
       ;; hex
       "a X i" #'alchemist-hex-info-at-point
       "a X I" #'alchemist-hex-info
       "a X s" #'alchemist-hex-search
     
       ;; tests
       "a t"     #'alchemist-mix-test
       "a m t f" #'alchemist-mix-test-file
       "a m t b" #'alchemist-mix-test-this-buffer
       "a m t ." #'alchemist-mix-test-at-point
     
       ;; documentation
       "a h h" #'alchemist-help
       "a h e" #'alchemist-help-search-at-point
     
       ;; jump to definition
       "a g d" #'alchemist-goto-definition-at-point)
   #+end_src
* Tools
  Some tools I frequently use are either Emacs based themselves or
  have nice Emacs frontents.
** =hledger=
   [[https://hledger.org/][hledger]] is a great tool for bookkeeping.  The [[https://github.com/narendraj9/hledger-mode][corresponding Emacs
   package]] adds syntax higlighting as well as completions (via
   =flycheck= that I do not use) and some practical expansions.
   #+begin_src emacs-lisp
     (use-package hledger-mode
       :mode "\\.journal\\'"
       :commands hledger-enable-reporting
       :load-path "straight/repos/hledger-mode"
       :hook (hledger-view-mode . #'hl-line-mode)
       :config
       (setq hledger-jfile "~/.hledger.journal")
       (add-to-list 'company-backends 'hledger-company))
     
     (defun hledger-visit-jfile ()
       (interactive)
       ;; TODO Use env variable for ledger file.
       (find-file "~/Box/Brain/Finance/ledger.journal"))
     
     (defun hledger/next-entry ()
       "Move to next entry and pulse."
       (interactive)
       (hledger-next-or-new-entry)
       (hledger-pulse-momentary-current-entry))
     
     (defun hledger/prev-entry ()
       "Move to last entry and pulse."
       (interactive)
       (hledger-backward-entry)
       (hledger-pulse-momentary-current-entry))
     
     (def-with-leader
       "f f e" #'hledger-visit-jfile)
     
     (def-local-with-leader
       :keymaps 'hledger-mode-map
       "r" #'hledger-run-command
       "e" #'hledger-jentry
       "p" #'hledger/prev-entry
       "n" #'hledger/next-entry)
   #+end_src
** =timeclock=
   Timeclock is a builtin Emacs package that allows you to easily
   check in and out in Emacs.  The best thing is that =hledger=
   understands the format and can generate reports based on a
   =.timeclock= file.  For example, to generate a weekly report from a
   timeclock file, just run:
   #+begin_src
     $ hledger -f path/to/tracking.timeclock register -W
   #+end_src

   The timeclock mode itself is easily configured:
   #+begin_src emacs-lisp
     ;; Timeclock allows me to clock in and out of projects and store it
     ;; in a format that hledger understands.
     (use-package timeclock
       :config
       (setq timeclock-file (expand-file-name  "~/Box/Brain/Timetracking/tracking.timeclock")
	     ;; 32h/Woche
	     ;; 384min/Tag
	     ;; 23040sec/tag
	     timeclock-workday 23040
	     timeclock-project-list '(general
				      phoenix)))
     
     (def-with-leader
       "t c i" #'timeclock-in
       "t c o" #'timeclock-out
       "f f t" #'timeclock-visit-timelog)
   #+end_src
